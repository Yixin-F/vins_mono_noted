3 imu预积分
3.1 旋转定义
    1）旋转矩阵：运算方便；使用9个量描述3个自由度旋转，引入额外模为1约束，求导困难
    2）旋转向量：紧凑的表示旋转；具有周期性
    3）欧拉角：直观；需要指定旋转顺序，存在万向锁死锁问题，无法进行球面平滑插值
    4）四元数：紧凑的不带奇异的表示方法；对用户来讲不太直观；要求单位ie四元数；过参数化
    在vins-mono中，涉及到协方差矩阵的传播使用旋转向量，因为ie误差卡尔曼滤波在0处波动，避免了旋转向量的周期性并且没有过参数化；
                                        涉及到预积分或普通旋转使用的是四元数；四元数与旋转向量之间相互转换方便，并且主要用到的近似式[cos(theta/2), n*sin(theta/2)]可以与陀螺仪读数w^直接联系(其中theta=(w^-bwt-nw)*deltat)
3.2 连续时间积分PVQ
    at^ = R(at-g)+bat+na   (bat和bwt都含下标时间t且不可测得，说明它俩是待优化量)
    wt^ = wt+bwt+nw
    q't = 1/2*omiga(w)*q = 1/2*omiga(w^-bwt-nw)*qt，则qt+1(w)  = qt(w) x F(q't)      其中，x表四元数右乘；F(q't)  表积分，得到qt+1(t)，这里的结果是t+1时刻在t时刻坐标下；qt(w)表t时刻在世界坐标系w下的位姿
3.3 为什么预积分
    通过连续两帧imu之间i与i+1的中值积分，给出三个预积分量，PVQ中先更新位姿Q，然后反向带入VQ。
    式中线加速度、角速度和位姿都采用到了中值方式，但是里面的零偏一直使用i时刻的零偏，说明这个零偏是不准的，是需要更新和补偿的
    因为整个系统采取的是一个滤波的过程，我们现在有了imu预积分状态和视觉重投影，但是协方差不知道，所以通过误差卡尔曼滤波来更新协方差(为了使用紧凑但有周期性的旋转向量)，协方差与雅克比有关即JT*E*J；
    同时进行零偏补偿
3.4 误差卡尔曼滤波ESKF
    为什么用ESKF？旋转向量；误差预测为0；二阶导忽略
3.5 连续时间下的ESKF预积分误差传递传递
    想要传递当然要求在i时刻的展开求导，即xi+1 = xi + xi'*deltat中的xi'      其中xi代表在i时刻的误差
    此时的imu预积分5个状态量求导是，x'=Fx+Gn    其中，n是噪声
4.1&4.2 离散时间预积分误差差传递
    根据xi+1 = xi + xi'*deltat，并且已经直到了连续时间下的导数xi'，带入连续时间的导数导数xi'，即为xi+1 = (1+F*deltat)*xi + G*deltat*ni
    
    那么只需要把其中的时间项换成中值积分形式即可变成离散时间
4.3 预积分零偏建模方式
    我们之前在i到i+1时刻的imu预积分里，假设零偏是不变的，但是零偏也是一个估计量且时刻在变化；
    那么问题来了，每次零偏估计依次不就意味着之前的预积分白做了？所以要根据新的零偏对原先的预积分结果进行依次补偿，所以我们需要额外计算PVQ对两个零偏的雅克比进行线性补偿
    雅克比矩阵是怎么求得？其实一开始的雅克比是初始化为对角阵，然后不断乘F，即Ji+1=F*Ji
4.4 协方差更新(自写)
    xi+1 = A*xi + B*ni   其中，xi的协方差是Pi，ni的协方差是Vi
    则，xi+1的协方差是A*Pi*AT + B*Vi*BT

5 VIO初始化(上)
5.1 初始化做了什么？
    包括纯视觉SFM和视觉与IMU对齐
    为什么初始化？因为整个系统是基于优化的，所以非常依赖于初始值
    初始化哪些变量？外参(旋转与平移)、零偏、地图点、PVQ
    但是加速度计零偏和平移外参一般不会初始化估计，加速度计零偏因包含重力所以不好求(甚至可以给个0左右的值影响也不大)，平移外参可以很容易通过外部工具直接测量(尺子)
5.2 数据预处理(1)
    读取yaml、条件锁
    imu_callback()读取imu数据存buf，并使用中值积分发布imu里程计
    feature_callback()读前端光流跟踪结果存buf
    process()结合imu_callback()和feature_callback()，通过时间戳整理若干组imu与视觉feature的组合，单独开辟一个线程且while(true)循环
5.3 数据预处理(2)
    processImu()处理process()所给组合中的imu数据，进行了预积分，这个预积分是每个滑窗内图像帧(包括kf和非kf)之间的预积分
    processImage()处理process()所给组合中的feature数据，进行滑窗内的边缘化和VIO初始化
5.4 数据预处理(3)
    processImage()处理process()所给组合中的feature数据，进行滑窗内的边缘化和VIO初始化
    先是addFeatureCheckParallax()添加所有特征点并且通过视差来判断是否是关键帧
5.5 旋转外参初始化
    多帧imu帧和图像帧同时构建超定方程，然后SVD分解

6 VIO初始化(下)
6.1&6.2 单目视觉位姿估计
    initialStructure()包括imu激励检测(其实作者抹去)、对kf进行纯视觉SFM得到枢纽帧与最后帧的位姿和地图点，并用pnp和三角化求其他kf的位姿和地图点、pnp和三角化求得all_image_frame中剩余帧帧(非kf)的位姿和地图点、视觉惯性对齐恢复尺度

