3 imu预积分
3.1 旋转定义
    1）旋转矩阵：运算方便；使用9个量描述3个自由度旋转，引入额外模为1约束，求导困难
    2）旋转向量：紧凑的表示旋转；具有周期性
    3）欧拉角：直观；需要指定旋转顺序，存在万向锁死锁问题，无法进行球面平滑插值
    4）四元数：紧凑的不带奇异的表示方法；对用户来讲不太直观；要求单位ie四元数；过参数化
    在vins-mono中，涉及到协方差矩阵的传播使用旋转向量，因为ie误差卡尔曼滤波在0处波动，避免了旋转向量的周期性并且没有过参数化；
                                        涉及到预积分或普通旋转使用的是四元数；四元数与旋转向量之间相互转换方便，并且主要用到的近似式[cos(theta/2), n*sin(theta/2)]可以与陀螺仪读数w^直接联系(其中theta=(w^-bwt-nw)*deltat)
3.2 连续时间积分PVQ
    at^ = R(at-g)+bat+na   (bat和bwt都含下标时间t且不可测得，说明它俩是待优化量)
    wt^ = wt+bwt+nw
    q't = 1/2*omiga(w)*q = 1/2*omiga(w^-bwt-nw)*qt，则qt+1(w)  = qt(w) x F(q't)      其中，x表四元数右乘；F(q't)  表积分，得到qt+1(t)，这里的结果是t+1时刻在t时刻坐标下；qt(w)表t时刻在世界坐标系w下的位姿
3.3 为什么预积分
    通过连续两帧imu之间i与i+1的中值积分，给出三个预积分量，PVQ中先更新位姿Q，然后反向带入VQ。
    式中线加速度、角速度和位姿都采用到了中值方式，但是里面的零偏一直使用i时刻的零偏，说明这个零偏是不准的，是需要更新和补偿的
    因为整个系统采取的是一个滤波的过程，我们现在有了imu预积分状态和视觉重投影，但是协方差不知道，所以通过误差卡尔曼滤波来更新协方差(为了使用紧凑但有周期性的旋转向量)，协方差与雅克比有关即JT*E*J；
    同时进行零偏补偿
3.4 误差卡尔曼滤波ESKF
    为什么用ESKF？旋转向量；误差预测为0；二阶导忽略
3.5 连续时间下的ESKF预积分误差传递传递
    想要传递当然要求在i时刻的展开求导，即xi+1 = xi + xi'*deltat中的xi'      其中xi代表在i时刻的误差
    此时的imu预积分5个状态量求导是，x'=Fx+Gn    其中，n是噪声
4.1&4.2 离散时间预积分误差差传递
    根据xi+1 = xi + xi'*deltat，并且已经直到了连续时间下的导数xi'，带入连续时间的导数导数xi'，即为xi+1 = (1+F*deltat)*xi + G*deltat*ni
    
    那么只需要把其中的时间项换成中值积分形式即可变成离散时间
4.3 预积分零偏建模方式
    我们之前在i到i+1时刻的imu预积分里，假设零偏是不变的，但是零偏也是一个估计量且时刻在变化；
    那么问题来了，每次零偏估计依次不就意味着之前的预积分白做了？所以要根据新的零偏对原先的预积分结果进行依次补偿，所以我们需要额外计算PVQ对两个零偏的雅克比进行线性补偿
    雅克比矩阵是怎么求得？其实一开始的雅克比是初始化为对角阵，然后不断乘F，即Ji+1=F*Ji
4.4 协方差更新(自写)
    xi+1 = A*xi + B*ni   其中，xi的协方差是Pi，ni的协方差是Vi
    则，xi+1的协方差是A*Pi*AT + B*Vi*BT

5 VIO初始化(上)
5.1 初始化做了什么？
    包括纯视觉SFM和视觉与IMU对齐
    为什么初始化？因为整个系统是基于优化的，所以非常依赖于初始值
    初始化哪些变量？外参(仅旋转)、陀螺仪零偏、地图点、PVQ、重力方向、尺度
    但是加速度计零偏和平移外参一般不会初始化估计，加速度计零偏因包含重力所以不好求(甚至可以给个0左右的值影响也不大)，平移外参可以很容易通过外部工具直接测量(尺子)作已知量
5.2 数据预处理(1)
    读取yaml、条件锁
    imu_callback()读取imu数据存buf，并使用中值积分发布imu里程计
    feature_callback()读前端光流跟踪结果存buf
    process()结合imu_callback()和feature_callback()，通过时间戳整理若干组imu与视觉feature的组合，单独开辟一个线程且while(true)循环
5.3 数据预处理(2)
    processImu()处理process()所给组合中的imu数据，进行了预积分，这个预积分是每个滑窗内图像帧(包括kf和非kf)之间的预积分
    processImage()处理process()所给组合中的feature数据，进行滑窗内的边缘化和VIO初始化
5.4 数据预处理(3)
    processImage()处理process()所给组合中的feature数据，进行滑窗内的边缘化和VIO初始化
    先是addFeatureCheckParallax()添加所有特征点并且通过视差来判断是否是关键帧
5.5 旋转外参初始化
    多帧imu帧和图像帧同时构建超定方程，然后SVD分解
    不同时刻，Imu帧预积分与图像帧重投影得到各自内部变化，建立在同一个外参之上

6 VIO初始化(下)
6.1&6.2 单目视觉位姿估计
    initialStructure()包括imu激励检测(其实作者抹去)、对kf进行纯视觉SFM得到枢纽帧与最后帧的位姿和地图点，并用pnp和三角化求其他kf的位姿和地图点、pnp和三角化求得all_image_frame中剩余帧帧(非kf)的位姿和地图点、视觉惯性对齐恢复尺度
6.3 基于ceres自动求导解决global BA
    虽然前面的sfm恢复了一个滑窗内的kf位姿和地图点，但这只是线性求解，所以需要使用ceres进行全局的BA得到最优非线性解
6.4 陀螺仪零偏估计
    现在我们的视觉sfm得到位姿是绝对准的，先在希望通过视觉与重力对齐来恢复尺度，但是我们目前得到的预积分没有考虑陀螺仪零偏，所以是不准的需要重新估计陀螺仪零偏，重新预积分
    那么我有个疑问？陀螺仪零偏估计需要之前估计的旋转外参，旋转外参也用到了不准的imu预积分，不需要重新估计吗？？因为在计算外参时只是可考虑了imu帧间内部相对变化，其实bias对齐影响不大
    另一个疑问？之前不是就算了对bias的雅克比，为什么要重新repropagate()？因为防止bias补偿过大不满足线性条件，所以重新预积分后，后续的imu预积分过程都是用的是雅克比，此时bias不会有太大变化
    solveGyroscopeBias()利用滑窗内图像求解陀螺仪零偏，同时用求出来的零偏重新进行预积分，我们不估计加速度计零偏
    基本思想是，“图像得到的Imu帧间约束的逆乘imu预积分的逆应该是单位四元数”，但是由于之前的imu预积分没有考虑到陀螺仪的零偏问题，所以加入零偏补偿使满足“.....”
    那么这时候陀螺仪零偏有了，那么之前所有的预积分不准了(还好先在只进行到了初始化阶段还未进入后端)，需要重新预积分(毕竟我们之前的imu已经存进了buf)即repropagate()
6.5 视觉惯性对齐
    之前的预积分，在PV部分，由于重力加速度存在，所以存在世界坐标系向Imu坐标系的转换。现在我们规定的是枢纽帧就是世界坐标系，所以要把预积分后的g转到枢纽帧对齐，p需要恢复尺度s，同时要每一帧的速度
    为什么要速度？？这个速度是指Imu的速度V？其实我们在imu中值积分阶段只是对每帧imu速度进行了简单的线性计算
    在vins优化器里我们已经得到了位置P和姿态Q，只是Q还没有对齐到重力坐标系下且P还有尺度问题，V并没有进行求解
    把世界坐标系规定为枢纽帧，即w变为c0，这需要c0与重力方向对齐，即g转换到c0系下，然后得到一个方程，没看懂.....
6.6 初始化位姿调整
    将滑窗内所有位姿转移到枢纽帧下，然后同时对齐到重力方向，这里让第0帧的yaw为0，那么枢纽帧为-yaw。最后滑窗里的第0帧仍是yaw为0且平移为0，那么roll和pitch就可观了

7 后端优化(上)
7.1 ceres的解析求导与核函数
    解析求导就是重载ceres基类的SizedCostFunction()中的接口函数Evaluate()，用户自己重新定义残差和雅克比，其中加入鲁棒核函数
7.2 数据预处理
    添加优化参数块，并将eigen类型数据转化为double数组，因为ceres只能优化double类类型数组
7.3 预积分残差计算
    15维残差PVQ和bias
7.4 预积分雅克比计算
    对两帧imu的PVQ和两个bias
    jacobian:
    |                15x7                                15x9                                      15x7                                             15x9                         |
    | |   偏e / 偏[Pk, Qk]   | |   偏e / 偏[Vk, biask]   | |    偏e / 偏[Pk+1, Qk+1]   | |   偏e / 偏[Vk+1, biask+1]   | |

8 后端优化(下)
8.1 视觉重投影
    两帧Imu位姿(R和t分别求导)、imu和相机外参和地图点逆深度
    残差是归一化后相机坐标与像素坐标之差
8.2 视觉雅克比
    链式法则

9 边缘化
9.1 滑动窗口边缘化含义
    在后端优化，一个滑窗内存在H * deltaX = b，其中H的形式是JT * J的形式，它是一个对称阵且是稀疏的，j关于位姿、地图点
    在一个滑窗内，H只需要维护Window_Size个帧，关于解决H * deltaX = b这个方程，当一个新的kf来临时，边缘化不仅可以保证不增加计算量还可以将被踢出的kf对后来的滑窗产生先验
    边缘化用到舒尔补，这会导致fill-in现象使得H不再稀疏，稠密矩阵的计算更久，针对这个问题，vins的做法是边缘化所有地图点，既然稠密点无法避免，那么索性减少H维数
9.2 边缘化
    1）创建边缘化因子，加入残差约束，包括第0帧和第1帧之间的imu约束、第0帧看到的所有视觉重投影约束
    2）预处理，包括参数块大小、计算残差和雅克比等
    3）多线程计算H * deltax = g，中的H和g，到此基本就结束了一个"手写VIO后端"的部分
    4）舒尔补进行边缘化，重新计算H和g
    5）https://blog.csdn.net/weixin_41394379/article/details/89975386
9.3 滑动窗口 
    根据边缘化有两种方式，一是去掉最老帧，二是去掉倒数第二帧
    特征管理部分没学好，部分没理解

10 回环检测
    重新提取brief描述子，使用dBow2进行回环匹配，然后PnP几何校验

